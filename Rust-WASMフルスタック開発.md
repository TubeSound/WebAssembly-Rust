

# まえがき

ウェブアプリケーションの構築手法は、今まさに変革の時を迎えています。開発者が速度、セキュリティ、そして信頼性を求める一方で、ユーザーはあらゆるデバイスにおいてスムーズかつリアルタイムな体験ができることを期待しています。長年にわたり、JavaScriptがブラウザ市場を独占してきました。しかし、パフォーマンスのボトルネックや安全性の課題、そして一貫性に欠けるツールチェーンといった要因が、新たな挑戦者が登場する余地を生み出しました。

メモリ安全性、並行性、そして「ゼロコスト抽象化」に重点を置く**Rust**は、その強力な選択肢として頭角を現しています。さらに、**WebAssembly (WASM)** と組み合わせることで、Rustはネイティブアプリに近いパフォーマンスをブラウザ上でもたらします。これらによって、フロントエンドとバックエンドの両方を同じ言語で動かすフルスタック開発が可能になりました。UI向けの **Leptos** やAPI向けの **Axum** といったフレームワークの登場により、このエコシステムは実用的かつ拡張性が高く、本番環境（プロダクション）にも耐えうるものへと進化しました。

本書は、モダンで高性能なウェブアプリケーションを「すべてRustで」構築したいと考えている開発者のために書かれました。プログラミングに関する基礎知識があることを前提としていますが、RustやWebAssemblyの経験は必要ありません。各章では、シグナルやリアクティビティ（反応性）の基本から、API連携、認証、リアルタイムでの共同作業を統合した実践的なプロジェクトまで、コンセプトを段階的に導入していきます。

## 本書で学ぶ内容：

* RustとWASMのツールチェーンのセットアップ
* Leptosによるリアクティブなフロントエンドの構築
* Axumによる堅牢なバックエンドの作成
* 非同期ワークフローを用いたデータの取得・管理・検証
* リアルタイムアプリケーションのためのWebSocketの統合
* 認証、セッション管理、およびセキュリティのベストプラクティスの実装
* 一貫性と保守性を高めるための、フロントエンド・バックエンド間でのコード共有
* フルスタックRustアプリケーションの本番環境へのデプロイ

本書を通して、すべてのサンプルは実際に動作するRustコードとして提示され、一行ずつ丁寧に解説されています。また、開発者が陥りやすい落とし穴を避け、自信を持ってプロダクションレベルのアプリケーションを書けるよう、ベストプラクティスについても触れています。

RustとWebAssemblyは、ウェブ開発の次なるステップを象徴しています。本書を読み終える頃には、これらがどのように連携するのかを理解するだけでなく、高速で安全、かつスケーラブルなウェブアプリケーションの潜在能力を最大限に引き出したプロジェクトを、自らの手で構築できるようになっているはずです。


---

# 第1章：RustとWebAssemblyの導入

## 1.1 ウェブ開発になぜRustを使うのか

ウェブ開発は長年、JavaScript、そして近年ではTypeScriptに大きく依存してきました。これらのツールはブラウザと深く結びついており、確固たる地位を築いています。しかし、アプリケーションが肥大化し、パフォーマンスへの要求が高まるにつれ、それらの限界が顕著になってきました。

Rustは、これらとは異なるアプローチを提供します。**安全性、速度、そして強力な並行性の保証**をウェブの世界にもたらすのです。

### なぜRustが重要なのか

* **ガベージコレクションなしのメモリ安全性**
Rustは「所有権（Ownership）」と「借用（Borrowing）」というシステムを通じて、厳格なルールを強制します。ヌルポインタの参照剥がしやデータ競合といったエラーはコンパイル時に捕捉されます。ガベージコレクションを採用する言語に特有の「予測不可能な一時停止（Stop-the-world）」が発生せず、アプリケーションがスムーズに動作します。
* **ネイティブに近いパフォーマンス**
Rustはマシンコードへ直接コンパイルされるため、CやC++に匹敵するパフォーマンスを発揮します。ウェブ開発においては、RustはWebAssembly（WASM）モジュールへとコンパイルされ、ブラウザ上でネイティブに近い速度で実行されます。データの可視化、シミュレーション、3Dレンダリングといった負荷の高いタスクでその真価を発揮します。
* **安全な並行処理**
Rustの型システムにより、データ競合のリスクを最小限に抑えながら並行アプリケーションを記述できます。これは、膨大な同時接続を処理するスケーラブルなバックエンドやアプリケーションを構築する際に大きな利点となります。
* **完成されたエコシステム**
* **フロントエンド・フレームワーク:** Leptos, Yew, Dioxus
* **バックエンド・フレームワーク:** Axum, Actix, Rocket
* **データベース:** SQLX, Diesel
これらが揃うことで、開発者はすべてのスタックをRustだけで構築することが可能になります。


### ベストプラクティスとヒント

* まずはデータ処理やリアルタイム機能など、**パフォーマンスが極めて重要な箇所**からRustを導入し、徐々に範囲を広げていきましょう。
* WebAssemblyのバイナリサイズを削減し、ロード時間を改善するために、コンパイル後のモジュールを最適化しましょう。
* オーバーヘッドを避けるため、Rust層とJavaScript層の間のデータ転送は最小限に抑えるのが賢明です。
* ネットワーク、シリアライズ、フロントエンド統合には、メンテナンスが活発な**クレート（Crate）**を利用しましょう。

### 避けるべき落とし穴（Common Pitfalls）

* **学習曲線の存在:** Rustの所有権ルールは、最初は非常に厳格に感じられるかもしれません。
* **エコシステムの成長途上:** 急速に成長していますが、すべてのJavaScript機能にRustの代替手段が存在するわけではありません。
* **デバッグの難易度:** WebAssemblyのデバッグ環境は向上していますが、JavaScriptのデバッグほど直感的でないと感じる場合があります。

### 実践的なユースケース

* 高性能なダッシュボードおよびデータの可視化
* **モバイルブラウザも対応:** モバイルブラウザもWebAssemblyを実装しているため、WASMはクロスプラットフォーム開発に適しています。
* **高いセキュリティ:** WebAssemblyは、JavaScriptと同様のサンドボックス構造により、安全に実行されるよう設計されています。これにより、システムリソースに直接アクセスできないことが保証されます。

### ベストプラクティスとヒント

* アプリ全体をWASMにするのではなく、**パフォーマンスのボトルネックとなっている部分**にWebAssemblyを使用しましょう。
* ダウンロード時間と初期化時間を短縮するため、モジュールは小さく保つようにしてください。
* JavaScriptとWASMの境界を越える呼び出しを最小限に抑え、**データ交換を最適化**しましょう。
* 統合を簡素化するために、LeptosのようなフレームワークとWASMを組み合わせることを検討してください。

### 避けるべき落とし穴（Common Pitfalls）

* **JavaScriptを完全に置き換えようとする:** これは不必要な複雑さを招くことが多いです。WASMはJavaScriptと組み合わせたときに最高のパフォーマンスを発揮します。
* **デバッグの未熟さ:** WebAssemblyのデバッグはJavaScriptほど成熟していません。ツールは進化していますが、ワークフローがスムーズでないと感じることがあります。
* **最適化不足:** 最適化されていない巨大なWASMバインド（一式）は、アプリケーションの起動を遅くします。

> **主要なポイント**
> WebAssemblyを利用することで、JavaScriptだけでは達成できない速度と安全性を備えたRustアプリケーションをブラウザで実行できます。これらはJavaScriptと共存し、それぞれが得意なタスクを分担します。強力なブラウザサポートと成長を続けるエコシステムにより、WASMはモダンで高性能なウェブアプリケーションを構築する上で不可欠なツールとなっています。

---

## 1.3 高パフォーマンスアプリにおけるRust対JavaScript

JavaScriptは何十年もの間、ウェブ開発の標準であり続けてきました。強力で柔軟性があり、どこでもサポートされています。一方、WebAssemblyにコンパイルされたRustは、**パフォーマンス、安全性、そして並行性**に焦点を当てた異なるアプローチをとります。これらは互いに競合するのではなく、組み合わせて使うことで補完し合う関係にあります。

### RustとJavaScriptの主な違い

| 項目 | JavaScript | Rust (WASMにコンパイル) |
| --- | --- | --- |
| **実行方式** | V8やSpiderMonkeyエンジンによる解釈実行、またはJITコンパイル | 効率的なマシン命令への事前（Ahead-of-time）コンパイル |
| **パフォーマンス** | 柔軟性に最適化されており、重い計算処理では低速になる | ネイティブに近い速度。CPU負荷の高いタスクに理想的 |
| **メモリ管理** | 自動ガベージコレクション（時折、処理の一時停止が発生する） | 所有権と借用ルールによる管理。ガベージコレクタなし |
| **並行処理** | イベントループと非同期コールバック。並列性は制限される | 安全なマルチスレッディングと大規模スケールに対応する非同期ランタイム |
| **ユースケース** | DOM操作、UIインタラクション、迅速なプロトタイピング | レンダリング、暗号化、リアルタイム分析、重いループ処理 |

### 例：数値の合計

**JavaScriptでの実装:**

```javascript
function sumToN(n) {
  let total = 0;
  for (let i = 0; i <= n; i++) {
    total += i;
  }
  return total;
}
console.log(sumToN(1_000_000));
```

**WebAssemblyにコンパイルするRustでの実装:**

```rust
#[wasm_bindgen]
pub fn sum_to_n(n: u32) -> u64 {
    let mut total: u64 = 0;
    for i in 0..=n {
        total += i as u64;
    }
    total
}
```

入力値が小さい場合、両者のパフォーマンスに大きな差はありません。しかし、値が大きくなるにつれ、効率的なバイナリ命令へとコンパイルされている Rust + WASM の方が、より高速かつ安定して動作します。

### ベストプラクティス

* JavaScriptは、その得意分野である **DOM操作、イベントハンドリング、UI** に使用しましょう。
* Rust + WebAssemblyは、**速度と安全性が重要となる重い計算処理**に使用しましょう。
* JSとWASMの境界を越える呼び出しは、操作をバッチ化（まとめて実行）することで最小限に抑えましょう。

> **主要なポイント**
> JavaScriptは柔軟性とブラウザネイティブのサポートを提供し、Rustはメモリ安全性とパフォーマンスをもたらします。これらを組み合わせることで、開発者はインタラクティブでありながら計算効率の高いアプリケーションを構築できます。

---

## 1.4 Rust + WASM エコシステム

Rustそれ自体も強力ですが、WebAssemblyと組み合わさることで、さらに豊かで成長著しいエコシステムの一部となります。このエコシステムには、フロントエンドとバックエンドの両方の構築を容易にするコンパイラ、ツール、ライブラリ、そしてフレームワークが含まれています。これらの構成要素を理解することは、プロジェクトに最適なアプローチを選択する助けとなります。

### 主要なツール

| ツール | 用途 |
| --- | --- |
| **wasm-pack** | RustコードをWebAssemblyモジュールへビルドし、パッケージ化する作業を自動化します。 |
| **wasm-bindgen** | RustとJavaScriptの間のバインディングを提供し、スムーズな相互運用（Interop）を可能にします。 |
| **trunk** | Rustウェブアプリ（特にフレームワークを使用するもの）向けのビルドツールおよびバンドラーです。 |
| **cargo-leptos** | Leptosプロジェクトのビルドを簡素化し、サーバー側とクライアント側の両方のビルドを管理します。 |

### フロントエンド・フレームワーク

| フレームワーク | 特徴 |
| --- | --- |
| **Leptos** | 「きめ細やかなリアクティビティ（fine-grained reactivity）」に焦点を当てており、フルスタックRustアプリを構築する際のAxumとの親和性が非常に高いです。 |
| **Yew** | Reactにインスパイアされた成熟したフレームワークで、RustによるSPA（シングルページアプリケーション）開発に適しています。 |
| **Dioxus** | クロスプラットフォーム開発を重視しており、一つのコードベースからウェブ、デスクトップ、モバイル向けのアプリを構築できます。 |

### バックエンドの統合

Rustの活躍の場はフロントエンドのWASMだけにとどまりません。バックエンド・フレームワークと自然に組み合わせることで、一貫した開発環境を構築できます。

| フレームワーク | 強み |
| --- | --- |
| **Axum** | 型安全で非同期第一（async-first）の設計。API、SSR（サーバーサイドレンダリング）、およびフルスタックプロジェクトに最適です。 |
| **Actix** | 非常に高いパフォーマンスを誇るフレームワークで、リアルタイム通信やマイクロサービスに優れています。 |
| **Rocket** | シンプルさと開発者の生産性に重点を置いており、直感的なAPI構築が可能です。 |

### データベースと状態管理

* **SQLX:** 非同期対応で、コンパイル時にSQLクエリの妥当性をチェックできるライブラリ。Rustのバックエンドで広く普及しています。
* **Diesel:** データベース操作における型安全性を強調した、ORM（オブジェクト関係マッピング）ライブラリ。
* **Redis + Rust クライアント:** キャッシュ処理やリアルタイムな状態管理（ステート管理）によく利用されます。

### コミュニティとエコシステムの成長

* Rust + WASMのエコシステムは、活発なコミュニティのサポートを受けて急速に拡大しています。

* **豊富なライブラリ:** 多くのオープンソースのクレート（Crate）が、シリアライズ、暗号化、ネットワーキング、そしてパフォーマンス最適化のためのユーティリティを提供しています。
* **標準化の進展:** カンファレンスやワーキンググループがWebAssemblyの標準化を推進し続けており、Rustはブラウザ内、さらにはブラウザ以外の環境においても「第一級市民（最優先される言語）」としての地位を確立しています。

> **主要なポイント**
> Rust + WASMのエコシステムは、フロントエンド用の **Leptos** からバックエンド用の **Axum**、そしてこれらをつなぐ **wasm-pack** や **wasm-bindgen** といったツールまで、フルスタックアプリケーションの構築に必要なすべてを網羅しています。コミュニティの力強い成長とブラウザサポートの拡大により、このエコシステムはウェブ開発において長期にわたって重要な役割を果たし続けるでしょう。


## 1.5 本書で構築するプロジェクト

RustとWebAssemblyの学習において、最も効果的なのは実践的なプロジェクトに応用することです。本書は、現実世界のアプリケーションを構築するプロセスを通じて、概念を段階的に学べるように構成されています。

各プロジェクトは、フロントエンドのインタラクティブ性から、バックエンドの統合、そしてデプロイまで、Rust + WASMエコシステムの異なる側面を実演できるように選定されています。

### プロジェクト1：LeptosとAxumによるブログプラットフォーム

* ユーザーが記事を作成・編集・閲覧できるシンプルなブログを構築します。
* フロントエンドは **Leptos** で記述し、WebAssemblyにコンパイルします。
* バックエンドは **Axum** と **SQLX** を使用し、投稿の管理、認証、およびデータベースへの保存を処理します。
* このプロジェクトを通じて、フルスタックRust開発の基礎を学びます。

### プロジェクト2：リアルタイム・チャットアプリケーション

* ライブ更新機能を備えたチャットアプリを実装します。
* リアルタイム通信には **WebSockets** を使用します。
* Rustの並行処理モデルを活かし、バックエンドが多数のユーザーを同時に処理できることを確認します。
* このプロジェクトでは、スケーラブルでインタラクティブなウェブアプリを構築するRustの能力に焦点を当てます。

### プロジェクト3：非同期APIを活用したデータダッシュボード

* 複数のAPIからデータを取得し、表示するダッシュボードを作成します。
* Rustの **非同期プログラミング（Async）** を駆使してデータ取得を効率化します。
* **Leptos** を使用してインターフェースをレンダリングし、新しいデータが届くたびにリアクティブに更新されるようにします。
* このプロジェクトでは、Rustの非同期エコシステムと、それを実務でどう活用するかに焦点を当てます。

### デプロイと最適化

各プロジェクトでは、パッケージ化、最適化、およびデプロイについてもカバーします。

* 本番環境（プロダクション）に対応したWASMバンドルのビルド。
* **Dockerによるデプロイと、Fly.io、AWS、Vercelといったプラットフォームでのホスティング。**
* **スムーズな開発ワークフローのためのCI/CDパイプラインの構築。**

### 本書で得られるもの

本書を読み終える頃には、以下のスキルが身についているはずです。

* **RustとWebAssemblyがモダンなウェブ開発でどのように連携するか**についての明確な理解。
* **Leptos、Axum、SQLX、および非同期Rust**を用いた実務経験。
* **本番環境に耐えうるウェブアプリケーション**を構築、テスト、最適化、およびデプロイする能力。
* 個人のプロジェクトであれ、プロフェッショナルな業務であれ、これらのスキルを自身のプロジェクトに応用できる自信。

> **主要なポイント**
> 本書は**プロジェクト主導型**です。構築する各アプリケーションは、リアクティブなUIのレンダリングから、リアルタイム通信の処理、スケーラブルなフルスタックアプリのデプロイまで、主要なコンセプトを補強するように設計されています。本書に沿って進めることで、実践的なプロジェクトの成果物と、WebAssembly開発のためのRustに関する確かな把握の両方を手に入れることができます。

---

# 第2章：環境構築とツールチェーン

## 2.1 Rust、Cargo、およびwasm-packのインストール

RustとWebAssemblyのアプリケーションを構築する前に、適切な開発環境を整える必要があります。このワークフローの基盤となるのは、**Rust**、**Cargo**、そして **wasm-pack** の3つのツールです。Rustはコンパイラを提供し、Cargoはプロジェクトと依存関係を管理し、wasm-packはRustをWebAssemblyおよびJavaScriptと橋渡しする役割を担います。

### RustupによるRustのインストール

Rustをインストールする推奨方法は、ツールチェーンを最新の状態に保つためのバージョン管理ツールである **rustup** を使用することです。

1. Rust公式サイトから `rustup` をダウンロードします。
2. インストーラーを実行し、デフォルト設定（通常は `1` を選択）を適用します。
3. インストールを確認します：
```bash
rustc --version
```


このコマンドでバージョンが表示されれば、Rustが正しくインストールされています。

### Rustのインストールに含まれるもの

* **rustc:** Rustコンパイラ。Rustのソースコードをコンパイルするために使用します。
* **cargo:** Rustのパッケージマネージャー兼ビルドツール。
* **rustup:** Rustのバージョンをインストールしたり切り替えたりするためのツール。

### Cargoの確認

CargoはRustに同梱されているため、インストール直後から使用可能です。確認するには以下のコマンドを打ちます：

```bash
cargo --version
```

Cargoは以下の作業に不可欠です：

* `cargo new` による新規プロジェクトの初期化。
* `Cargo.toml` ファイルを通じた依存関係（ライブラリ）の管理。
* ビルド、テスト、およびベンチマークの実行。

### Wasm-Packのインストール

**wasm-pack** は、RustコードをWebAssemblyにコンパイルし、それに対するJavaScriptバインディング（接続用コード）を生成するツールです。これにより、Rustコードをウェブプロジェクトでシームレスに使用できるようになります。

Cargoを使用して `wasm-pack` をインストールします：

```bash
cargo install wasm-pack
```

インストールを確認します：

```bash
wasm-pack --version
```

### 最初のテスト：シンプルなプロジェクトのビルド

1. 新しいプロジェクトを作成します：
```bash
cargo new wasm_test
cd wasm_test
```


2. Cargoでプロジェクトをビルドします：
```bash
cargo build
```


3. WebAssemblyにコンパイルします：


```bash
wasm-pack build --target web
```

このコマンドがエラーなしで完了すれば、セットアップは正常に動作しています。

### ベストプラクティスとヒント

* **Rustを最新に保つ:** 定期的に `rustup update` を実行しましょう。
* **PATHの確認:** コマンドが認識されない場合は、Cargoの `bin` ディレクトリがシステムの環境変数（PATH）に追加されているか確認してください。
* **Stable（安定版）を使う:** プロジェクトで明示的にNightly（開発版）の機能が必要とされていない限り、安定版のRustを使用しましょう。
* **wasm-packの更新:** 最新のWebAssembly規格に対応するため、`wasm-pack` も定期的にアップデートしてください。

### 避けるべき落とし穴（Common Pitfalls）

* **PATH設定の漏れ:** `cargo` や `wasm-pack` が「コマンドが見つかりません」となる主な原因です。
* **古いRustバージョン:** Leptosのようなモダンなフレームワークでは、古いRustだとコンパイルが通らないことがあります。
* **検証のスキップ:** `wasm-pack` の動作確認を怠ると、後で複雑なビルドエラーに悩まされる原因になります。

> **主要なポイント**
> 現時点で、Rust + WebAssemblyの完全な環境が整いました。Rustがコンパイラを提供し、Cargoがビルドと依存関係を管理し、wasm-packがRustをブラウザですぐに使えるWebAssemblyモジュールへとコンパイルします。これで、実際のアプリケーション構築に進む準備が整いました。

---

## 2.2 wasm-bindgen、trunk、およびcargo-leptos

Rust、Cargo、wasm-packをインストールした後は、開発をさらに効率化するための追加ツールが必要です。特に重要なのが **wasm-bindgen**、**trunk**、そして **cargo-leptos** の3つです。これらは、生産性を向上させながら、Rust、WebAssembly、そしてブラウザの間のギャップを埋める役割を果たします。

### wasm-bindgen：RustとJavaScriptを接続する

**wasm-bindgen** は、JavaScriptからRustの関数を呼び出したり、逆にブラウザのAPIをRust側に公開したりすることを可能にします。これがないと、WebAssemblyモジュールは低レベルすぎて実用的な開発が困難になります。

**1. Cargo.tomlに依存関係を追加する:**

```toml
[dependencies]
wasm-bindgen = "0.2"
```

**2. Rustコードでインポートする:**

```rust
use wasm_bindgen::prelude::*;
```

**3. JavaScriptからアクセス可能にするためにアノテーション（属性）を付ける:**

```rust
#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}
```

データの受け渡しは、細かな転送を繰り返すのではなく、まとめて（バッチで）行うのが効率的です。よくある間違いは `#[wasm_bindgen]` 属性を付け忘れることで、これでは関数がエクスポートされません。また、サポートされていない複雑な型を境界を越えて渡そうとすることも、ビルドエラーの原因となるため注意が必要です。

### Trunk：Rustウェブアプリのビルドとバンドル

**Trunk** は、Rust + WASM アプリケーションのビルド、バンドル、およびローカルサーバーの立ち上げを自動化するツールです。JavaScriptにおける Webpack や Vite のような役割を果たしますが、Rustプロジェクトに特化して設計されています。

* **Trunkをグローバルにインストールする:**
`cargo install trunk`
* **ホットリロード機能付きの開発サーバーを起動する:**
`trunk serve`

Trunkは、ビルドプロセスの起点としてプロジェクトのルートにある `index.html` を参照します。ホットリロード（コード変更の即時反映）、静的アセットの管理、依存関係の解決などを代行し、開発を大幅に簡略化してくれます。古いバージョンの Trunk は互換性の問題を引き起こす可能性があるため、常に最新版を使用することを推奨します。また、`index.html` が存在しない、あるいは設定が間違っているとエラーになることが多いため注意しましょう。

### cargo-leptos：フルスタックLeptosプロジェクトの簡素化

**cargo-leptos** は、Leptos（フロントエンド）と Axum（バックエンド）を一つのワークフローに統合するためのツールです。WebAssemblyによるフロントエンドと、サーバーサイドレンダリング（SSR）を行うバックエンドの両方を一括で管理します。

* **cargo-leptosをインストールする:**
`cargo install cargo-leptos`
* **Leptosアプリをビルドして起動する:**
`cargo leptos serve`

cargo-leptosは、共通のクレート構造を推奨することで、クライアントとサーバー間での**コード共有**を容易にします。これにより、バリデーションロジックなどを両方の環境で再利用できます。また、標準でSSR（サーバーサイドレンダリング）を提供するため、パフォーマンスとSEO（検索エンジン最適化）が向上します。実行時エラーを避けるため、使用する Leptos のバージョンと `cargo-leptos` のバージョンを合わせるようにしてください。

> **主要なポイント**
> `wasm-bindgen`、`trunk`、そして `cargo-leptos` が揃うことで、Rust + WebAssembly の開発環境が完成します。これらのツールは JavaScript との通信を簡略化し、ビルドやホットリロードを自動化し、フルスタックのワークフローを一本化してくれます。これらこそが、モダンな Rust ウェブ開発のバックボーンとなります。


## 2.3 Rust + WASM プロジェクトの整理

Rust と WebAssembly でアプリケーションを構築する場合、**コードそのものと同じくらい「整理（構成）」が重要**です。クリーンな構造にすることで、依存関係の管理、クライアントとサーバー間でのコード共有、そしてプロジェクトが成長した際のスケーリングが容易になります。初心者はすべてを一つの場所に詰め込もうとしがちですが、大規模なプロジェクトでは責任の所在を明確に分ける（疎結合にする）ことが大きな利益をもたらします。

### 新しいプロジェクトの作成

WebAssemblyのターゲットは「ライブラリ」としてコンパイルされるため、まずはライブラリ形式のクレートから始めます。

```bash
cargo new wasm_app --lib
cd wasm_app
```

これによって、`Cargo.toml` ファイルと `src/lib.rs` ソースファイルを備えたプロジェクトディレクトリが作成されます。バイナリ（単体実行ファイル）ではなく**ライブラリ**として作成することで、Rustの関数をJavaScriptやLeptosへ確実にエクスポートできるようになります。

### 基本的なプロジェクト構成

シンプルな Rust + WASM プロジェクトは、通常以下のような構成になります。

```text
wasm_app/
├── Cargo.toml      # 依存関係とメタデータの定義
├── src/
│   └── lib.rs      # WebAssemblyにコンパイルされるRustコード
├── index.html      # Trunkがアプリを配信するためのエントリーポイント
├── package.json    # オプション。npmワークフローと統合する場合に便利
└── static/
    └── styles.css  # CSS、画像、その他のアセットを格納
```

### フルスタックプロジェクトの整理

フロントエンド（WASM）と Axum によるバックエンドサーバーを組み合わせる場合は、**Cargoワークスペース（Workspace）**を使用して複数のクレートに分けるのが最善です。これにより、共通ライブラリを通じてコードを共有しながら、各パーツを独立して開発・コンパイルできるようになります。

```text
fullstack-app/
├── Cargo.toml       # ワークスペース全体の定義
├── client/          # Leptos + WASM フロントエンド
│   └── src/lib.rs
├── server/          # Axum バックエンド
│   └── src/main.rs
└── shared/          # 共有モデル、バリデーション、ロジック
    └── src/lib.rs
```

* **client クレート:** WebAssemblyにコンパイルされ、ブラウザ上で動作します。
* **server クレート:** バックエンドで動作し、APIの公開やLeptosによるレンダリングを担当します。
* **shared クレート:** 再利用可能な型定義、バリデーションロジック、定数などを格納します。

このパターンを採用することで、コードの重複を防ぎ、クライアントとサーバーの間で一貫したデータ処理を保証できます。

### ベストプラクティス

* 見通しを良くするため、クライアント、サーバー、共有ロジックは常に**別々のクレート**に保ちましょう。
* スタイルシート、アイコン、JavaScriptファイルなどのすべてのアセットは、専用の `static/` フォルダに集約してください。


* **ワークスペースの活用:** 大規模なプロジェクトではワークスペースを活用しましょう。依存関係の管理が格段に楽になります。
* **最小限のエクスポート:** WebAssemblyをターゲットにする場合、`lib.rs` で公開（export）するのは必要なものだけに絞ってください。
* **構成のドキュメント化:** 新しい開発者がすぐにレイアウトを理解できるよう、ディレクトリ構造を文書化しておきましょう。

### 避けるべき落とし穴（Common Pitfalls）

* **コードの混在:** サーバーとクライアントのコードを一つのクレートに混ぜてしまうと、高確率でコンパイルエラーの沼にハマります。
* **`--lib` の指定漏れ:** プロジェクト作成時にライブラリとしてマークし忘れると、WebAssemblyのビルドが正しく行われません。
* **アセットの散散:** 画像やCSSなどのアセットがバラバラのディレクトリにあると、Trunkや `cargo-leptos` が正しくバンドルできなくなります。

> **まとめ**
> Rust + WASM プロジェクトを最初から正しく整理しておくことは、将来の開発に向けた強固な基盤となります。クライアント、サーバー、共有コードを明確に分けることで、エラーが減り、ビルドが速くなり、拡張性が向上します。クリーンな構造さえ整えば、ビルドシステムと戦うのではなく、機能の実装に集中できるようになります。


## 2.4 ビルドと実行のワークフロー

プロジェクトが整理できたら、次はそれを効率的にビルドして実行する方法を学びます。Rust + WebAssembly のワークフローには、Rustソースコードのコンパイル、WebAssemblyモジュールの生成、そしてブラウザでの配信が含まれます。適切なツールを使えば、このプロセスはスムーズで予測可能なものになり、開発スピードが大幅に向上します。

### Cargoによるビルド

Rustプロジェクトは **Cargo** を使ってビルドされます。Cargoはコードのコンパイル、依存関係の管理、テストの実行をすべて担います。

1. プロジェクトディレクトリに移動します。
2. 標準ビルドを実行します：
```bash
cargo build --target wasm32-unknown-unknown
```

`--target wasm32-unknown-unknown` フラグは、ネイティブの実行ファイル（.exeなど）ではなく、**WebAssemblyターゲット向けにコンパイルせよ**という指示です。これにより、`target` ディレクトリ内に `.wasm` ファイルが生成されます。

### wasm-packによるWebAssemblyビルド

Cargoだけでも `.wasm` ファイルは作れますが、ほとんどのプロジェクトでは **wasm-pack** を利用します。これは、ブラウザでWASMを使うために不可欠な「JavaScriptバインディング（接着剤となるコード）」を同時に生成してくれるからです。

以下のコマンドでビルドを実行します：

```bash
wasm-pack build --target web
```

このコマンドにより、`.wasm` モジュールと、それをロードするためのJavaScriptの「接着剤コード」を含む `pkg/` ディレクトリが作成されます。`--target web` オプションにより、ブラウザ環境との互換性が保証されます。

### Trunkによる実行

ビルドやサーバーの設定を手動で行う代わりに、**Trunk** がプロセスを自動化してくれます。Trunkはファイルの変更を監視し、自動で再ビルドしてブラウザをリロード（ホットリロード）します。

開発サーバーを起動するには：

```bash
trunk serve
```

Trunkはプロジェクトのルートにある `index.html` を探し出し、アセットをバンドルして、ローカルで配信を開始します。このセットアップは、試行錯誤を繰り返す反復的な開発に最適です。


### **cargo-leptos によるフルスタック・ワークフロー**

Leptos フロントエンドと Axum バックエンドの両方を含むアプリケーションを構築する場合、推奨されるツールは **`cargo-leptos`** です。このコマンドは、クライアント側の WebAssembly コードとサーバー側のバイナリの両方をビルドし、それらを組み合わせて配信します。

**ビルドと実行の手順：**

```bash
cargo leptos serve
```

これにより、ブラウザが WebAssembly にコンパイルされた Leptos フロントエンドを読み込む一方で、Axum バックエンドが API 処理やサーバーサイドレンダリング（SSR）を担当するというワークフローが構築されます。


### **ベストプラクティス**

* **リリースビルドの活用**: 本番環境向けには `cargo build --release` を使用し、最適化された WebAssembly モジュールを生成してください。
* **ホットリロードの利用**: 開発中は `trunk serve` または `cargo leptos serve` を活用し、ホットリロードの利便性を享受しましょう。
* **Cargo.toml の整理**: `Cargo.toml` は常にクリーンに保ち、必要な依存関係のみを含めるようにしてください。依存関係が増えるたびにビルド時間が延びることになります。
* **ワークスペースの活用**: クライアント、サーバー、共有用のクレートがある場合は、ワークスペースを使用して調整されたビルドを簡素化してください。

### **よくある落とし穴**

* **ターゲットの指定忘れ**: WebAssembly ターゲットの指定を忘れると、`.wasm` ではなく通常のネイティブバイナリが出力されてしまいます。
* **巨大なバンドルサイズ**: `.wasm` バンドルが大きすぎるとロード時間が長くなります。`wasm-opt` などのツールを使用してサイズを縮小しましょう。
* **アセットの欠落**: `index.html` や適切な静的アセットなしで Trunk を実行すると、ビルドが不完全になります。
* **バージョンの不一致**: Leptos と `cargo-leptos` の互換性のないバージョンを混在させると、ビルドプロセス中に実行時エラーが発生する可能性があります。

## **2.5 はじめての Rust + WASM プログラム**

ビルドと実行のワークフローが整ったところで、実際に WebAssembly にコンパイルしてブラウザで実行される、最初の Rust プログラムを作成してみましょう。このシンプルなプロジェクトを通じて、「Rust コードの記述」「WebAssembly へのコンパイル」「バインディングの生成」「HTML ページ内での JavaScript との連携」という一連のパイプラインを体験できます。

### **ステップ 1：プロジェクトの作成**

まず、新しい Rust ライブラリプロジェクトを作成します。

```bash
cargo new hello_wasm --lib
cd hello_wasm
```

> **注意点：** WebAssembly のエクスポートはバイナリではなくライブラリクレートを通じて行われるため、`--lib` フラグが非常に重要です。

### **ステップ 2：wasm-bindgen 依存関係の追加**

`Cargo.toml` を開き、`wasm-bindgen` クレートを追加します。

```toml
[dependencies]
wasm-bindgen = "0.2"
```

このクレートは、JavaScriptがRustの関数を呼び出したり、その逆を行ったりするために必要なバインディングを生成します。

### ステップ3：簡単なRust関数の作成

`src/lib.rs` を開き、挨拶を返す関数を記述します。

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    format!("Hello, {}! Welcome to Rust + WASM.", name)
}
```

`#[wasm_bindgen]` 属性を付けることで、この関数がJavaScript側から参照できるようになります。

### ステップ4：wasm-packによるビルド

プロジェクトをWebAssemblyにコンパイルし、JavaScriptバインディングを生成します。

```bash
wasm-pack build --target web
```

これにより、`.wasm` ファイルとJavaScriptの「接着剤コード（グルーコード）」を含む `pkg/` ディレクトリが作成されます。

### ステップ5：HTMLファイルの作成

プロジェクトのルートに、WebAssemblyモジュールを読み込むための `index.html` ファイルを作成します。

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hello Rust + WASM</title>
</head>
<body>
    <h1 id="output"></h1>
    <script type="module">
        import init, { greet } from "./pkg/hello_wasm.js";
        async function run() {
            await init();
            document.getElementById("output").textContent = greet("Developer");
        }
        run();
    </script>
</body>
</html>
```

この例では、Rustで生成されたモジュールをインポートして初期化（init）し、`greet` 関数を呼び出しています。実行結果はブラウザに表示されます。

### ステップ6：Trunkで配信する

サーバーを手動で設定する代わりに、Trunkを使用してアプリケーションをローカルで配信します。

```bash
trunk serve
```

これによりプロジェクトがコンパイルされ、HTMLが配信されます。また、ファイルが変更されると自動的にリロードされます。ブラウザで `http://127.0.0.1:8080` を開くと、ページに挨拶文が表示されるはずです。

**ベストプラクティス**

アップロードしていただいた画像2枚分、第2章の仕上げとなる「ベストプラクティス」と「まとめ」までを翻訳しました。

これで、「Hello WASM」プロジェクトのライフサイクルがすべて完了します。


## ベストプラクティス（Best Practices）

* **分かりやすい関数名を使用する**: Rustの関数をエクスポートする際は、JavaScript側で何をする関数なのかが明確になるような名前を付けましょう。
* **境界（Boundary）を最小限に保つ**: パフォーマンスのオーバーヘッドを避けるため、RustとJavaScriptの間でのデータのやり取りは最小限に抑えてください。
* **コードを整理する**: エクスポートする関数は `lib.rs` にまとめ、内部的なロジックは別のモジュールに分けて管理しましょう。
* **バージョン管理の対象を絞る**: `Cargo.toml` と `src/` ディレクトリはGitにコミットしますが、`pkg/` ディレクトリはいつでも再生成できるため、対象から除外（ignore）してください。
* **ビルドツールの使い分け**: `cargo build` を実行しても、ブラウザで必要なバインディング（接続用コード）は生成されません。必ず `wasm-pack build` を使用してください。
* **データ型に注意する**: シリアライズ（共通形式への変換）を行わずに複雑な構造体など、サポートされていないデータ型をRustとJavaScript間で渡そうとすると、ビルドエラーの原因になります。


## よくある落とし穴（Common Pitfalls）

* **`#[wasm_bindgen]` 属性の付け忘れ**: これを忘れると、生成されたバインディング内に関数が含まれず、JavaScriptから呼び出すことができません。

## まとめ

この最初のプロジェクトを通じて、Rustコードの記述、WebAssemblyへのコンパイル、そしてブラウザでの実行という**一連のライフサイクル**を体験しました。この基礎的な例は、今後取り組む「フロントエンドの反応性を高める **Leptos**」や「バックエンドサービスを構築する **Axum**」といった、より高度なアプリケーション開発のための土台となります。

---